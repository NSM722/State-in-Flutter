# Flutter State Management

```dart
// starter template
class HomePage extends ConsumerWidget {
  const HomePage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      appBar: AppBar(
        title: const Text(
          'Home Page',
        ),
      ),
      body: const Center(
        child: Text(
          '....',
        ),
      ),
    );
  }
}
```

## [Flutter Hooks](https://pub.dev/packages/flutter_hooks)

## Riverpod

Riverpod is a simple way to access your state and manage your state in Flutter.

It is a Provider replacement that is more powerful and easier to use.

### Type aliases

A type alias is a way to give a type a different name making the code more readable.

```dart
// Type alias
typedef BasketballScore = int;

// Using the type alias
BasketballScore score = 10;
```

### Provider

A provider is a global object that can be accessed anywhere in the app and provides a value to a widget.

### Notifier class concept

A notifier class is a class that has a state and can notify listeners when the state changes. This class is implicitly generated by Riverpod when one creates a `StateProvider` or `StateNotifierProvider`.

### StateNotifier

StateNotifier is a class that has a state and can notify listeners when the state changes.

One can read the state and modify the state.

### StateNotifierProvider

This is a provider that provides a StateNotifier to the widget tree.

### ConsumerWidget

This is a stateless widget that listens to changes to a provider and rebuilds when the provider changes.

This means the UI will update when the provider changes.

`ref.watch()` - Listens to changes in a provider and rebuilds the widget when the provider changes.

`ref.read()` - Reads the current value of a provider without listening to changes.

### StateProvider

This is a simple provider that provides a value that can be read and modified.

When you create a state `provider` using `StateProvider`, Riverpod automatically generates a corresponding notifier class behind the scenes. This notifier class is responsible for updating the state and notifying any listeners when the state changes

### FutureProvider

This provider is used to asynchronously provide data to the widget tree, commonly employed for fetching data from APIs or databases.

It has three states:

- `loading` - Indicates the future is still loading and data has not been fetched yet
- `error` - Signifies an error in the future during fetching. The error message and stack trace are passed as arguments
- `data` - When the future has completed successfully

One can use the `when` method to access the result of the future. This method allows one to handle the three states of the future.

Depending on the state of the future, the appropriate function is executed, allowing one to handle each state accordingly

```dart
// Example code for FutureProvider
class UserData {
  final String name;
  final int age;

  UserData(this.name, this.age);
}

final userDataProvider = FutureProvider<UserData>((ref) async {
  // Simulating an asynchronous operation
  await Future.delayed(Duration(seconds: 2));

  // Fetching user data from an API or database
  final userData = await fetchUserData();

  return userData;
});

class HomePage extends ConsumerWidget {
  const HomePage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Home Page'),
      ),
      body: Center(
        child: ref.watch(userDataProvider).when(
          loading: () => CircularProgressIndicator(),
          error: (error, stackTrace) => Text('Error: $error'),
          data: (userData) => Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text('Name: ${userData.name}'),
              Text('Age: ${userData.age}'),
            ],
          ),
        ),
      ),
    );
  }
}
```
